#!/usr/bin/env bash

################################################################################
# pre-commit - Git Pre-Commit Hook for Dotfiles
#
# This hook runs before each commit to ensure:
# - No sensitive data is being committed
# - Shell scripts are executable
# - No syntax errors in shell scripts
# - File permissions are correct
################################################################################

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${GREEN}Running pre-commit checks...${NC}\n"

FAILED=false

################################################################################
# Check 1: No Sensitive Data
################################################################################

echo "Checking for sensitive data..."

# Patterns that might indicate sensitive data (improved to avoid false positives)
# These patterns look for non-empty values after the = sign
SENSITIVE_PATTERNS=(
    'password\s*=\s*['\''"][^'\''"]{3,}['\''"]'        # password = "something" (3+ chars)
    'api[_-]?key\s*=\s*['\''"][^'\''"]{10,}['\''"]'    # api_key = "something" (10+ chars)
    'secret\s*=\s*['\''"][^'\''"]{3,}['\''"]'          # secret = "something" (3+ chars)
    'token\s*=\s*['\''"][^'\''"]{10,}['\''"]'          # token = "something" (10+ chars)
    'BEGIN RSA PRIVATE KEY'
    'BEGIN OPENSSH PRIVATE KEY'
    'BEGIN PGP PRIVATE KEY'
)

# Files to check (staged files only, excluding this hook itself and test files)
FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -v "scripts/pre-commit" | grep -v ".test" || true)

if [ -z "$FILES" ]; then
    echo -e "${GREEN}✓ No files to check for sensitive data${NC}\n"
else
    for pattern in "${SENSITIVE_PATTERNS[@]}"; do
        # Check each file individually to provide better context
        while IFS= read -r file; do
            if [ -f "$file" ]; then
                if grep -iEq "$pattern" "$file" 2>/dev/null; then
                    echo -e "${RED}✗ Potentially sensitive data found in: $file${NC}"
                    echo -e "${YELLOW}Pattern: $pattern${NC}"
                    echo -e "${YELLOW}Please review and remove sensitive data before committing.${NC}"
                    FAILED=true
                fi
            fi
        done <<< "$FILES"
    done

    if [ "$FAILED" = false ]; then
        echo -e "${GREEN}✓ No sensitive data detected${NC}\n"
    fi
fi

################################################################################
# Check 2: Shell Script Syntax
################################################################################

echo "Checking shell script syntax..."

# Find all shell scripts being committed
SHELL_SCRIPTS=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(sh|bash|zsh)$' || true)

if [ -n "$SHELL_SCRIPTS" ]; then
    for script in $SHELL_SCRIPTS; do
        if [ -f "$script" ]; then
            # Determine which shell to use for syntax check
            syntax_checker="bash"
            if [[ "$script" == *.zsh ]] || [[ "$script" == *"/zsh/"* ]]; then
                syntax_checker="zsh"
            fi

            # Check syntax with appropriate shell
            if $syntax_checker -n "$script" 2>/dev/null; then
                echo -e "${GREEN}✓ $script${NC}"
            else
                echo -e "${RED}✗ Syntax error in $script${NC}"
                $syntax_checker -n "$script"
                FAILED=true
            fi

            # Check if executable (skip for sourced files like functions.zsh)
            if [[ "$script" == *.sh ]] || [[ "$script" == *.bash ]]; then
                if [ -x "$script" ]; then
                    echo -e "${GREEN}  ✓ Executable${NC}"
                else
                    echo -e "${YELLOW}  ⚠ Not executable (consider: chmod +x $script)${NC}"
                fi
            fi
        fi
    done
else
    echo -e "${GREEN}✓ No shell scripts to check${NC}"
fi

echo ""

################################################################################
# Check 3: Verify Critical Files
################################################################################

echo "Verifying critical files..."

CRITICAL_FILES=(
    "bootstrap/bootstrap.sh"
    "bootstrap/brewfile"
    "bootstrap/macos-defaults.sh"
    "stow/zsh/.zshrc"
    "stow/git/.gitconfig"
)

for file in "${CRITICAL_FILES[@]}"; do
    if git diff --cached --name-only | grep -q "$file"; then
        if [ -f "$file" ]; then
            # Check if file is not empty
            if [ -s "$file" ]; then
                echo -e "${GREEN}✓ $file exists and is not empty${NC}"
            else
                echo -e "${RED}✗ $file is empty!${NC}"
                FAILED=true
            fi
        fi
    fi
done

echo ""

################################################################################
# Check 4: No .DS_Store Files
################################################################################

echo "Checking for .DS_Store files..."

if git diff --cached --name-only | grep -q "\.DS_Store"; then
    echo -e "${RED}✗ .DS_Store file detected in commit${NC}"
    echo -e "${YELLOW}Run: git rm --cached .DS_Store${NC}"
    FAILED=true
else
    echo -e "${GREEN}✓ No .DS_Store files${NC}"
fi

echo ""

################################################################################
# Check 5: Large Files
################################################################################

echo "Checking for large files..."

# Find files larger than 1MB
LARGE_FILES=$(git diff --cached --name-only --diff-filter=ACM | while read file; do
    if [ -f "$file" ]; then
        size=$(wc -c < "$file")
        if [ "$size" -gt 1048576 ]; then  # 1MB in bytes
            echo "$file ($((size / 1024 / 1024))MB)"
        fi
    fi
done)

if [ -n "$LARGE_FILES" ]; then
    echo -e "${YELLOW}⚠ Large files detected:${NC}"
    echo "$LARGE_FILES"
    echo -e "${YELLOW}Consider if these files should really be in the repository.${NC}"
else
    echo -e "${GREEN}✓ No large files${NC}"
fi

echo ""

################################################################################
# Check 6: Trailing Whitespace
################################################################################

echo "Checking for trailing whitespace..."

if git diff --cached --check 2>&1 | grep -q "trailing whitespace"; then
    echo -e "${YELLOW}⚠ Trailing whitespace detected${NC}"
    git diff --cached --check
    echo -e "${YELLOW}Consider removing trailing whitespace.${NC}"
else
    echo -e "${GREEN}✓ No trailing whitespace${NC}"
fi

echo ""

################################################################################
# Check 7: Commit Message Template
################################################################################

# Create a commit message template if it doesn't exist
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    # Check if commit message is too short
    MSG_LENGTH=$(grep -v '^#' "$COMMIT_MSG_FILE" | wc -c)
    if [ "$MSG_LENGTH" -lt 10 ]; then
        echo -e "${YELLOW}⚠ Commit message might be too short${NC}"
        echo -e "${YELLOW}Consider a more descriptive message.${NC}"
    fi
fi

################################################################################
# Summary
################################################################################

echo -e "\n${GREEN}===========================================${NC}"

if [ "$FAILED" = true ]; then
    echo -e "${RED}Pre-commit checks FAILED${NC}"
    echo -e "${YELLOW}Please fix the issues above and try again.${NC}"
    echo -e "${GREEN}===========================================${NC}\n"
    exit 1
else
    echo -e "${GREEN}All pre-commit checks PASSED ✓${NC}"
    echo -e "${GREEN}===========================================${NC}\n"
    exit 0
fi
